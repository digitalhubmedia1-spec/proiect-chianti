-- 1. Create the new Header table
CREATE TABLE IF NOT EXISTS defined_recipes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  preparation_method TEXT,
  linked_product_id BIGINT REFERENCES products(id) ON DELETE SET NULL, -- Optional link to a menu product
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(name)
);

-- 2. Migrate existing data
-- Current 'recipes' table has multiple rows per product_id. We need to create ONE header per product_id.
INSERT INTO defined_recipes (linked_product_id, name, preparation_method)
SELECT 
    r.product_id, 
    p.name, 
    MAX(r.preparation_method) as preparation_method
FROM recipes r
JOIN products p ON r.product_id = p.id
GROUP BY r.product_id, p.name
ON CONFLICT (name) DO NOTHING; -- Avoid duplicates if re-running

-- 3. Update 'recipes' table (which is actually RecipeIngredients)
-- Add new FK
ALTER TABLE recipes ADD COLUMN IF NOT EXISTS recipe_id BIGINT REFERENCES defined_recipes(id) ON DELETE CASCADE;

-- Populate recipe_id based on product_id
UPDATE recipes r
SET recipe_id = dr.id
FROM defined_recipes dr
WHERE r.product_id = dr.linked_product_id;

-- 4. Alter 'recipes' table schema
-- Now that we have recipe_id, we don't strictly need product_id or preparation_method here anymore.
-- BUT, dropping columns can be destructive if migration failed. We will make them nullable for now or drop them if confident.
-- Let's drop them to ensure we rely on the new structure.

ALTER TABLE recipes DROP COLUMN product_id;
ALTER TABLE recipes DROP COLUMN preparation_method;

-- Add RLS to new table
ALTER TABLE defined_recipes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Enable all for authenticated" ON defined_recipes FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');
